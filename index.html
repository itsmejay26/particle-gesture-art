<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture Particle Universe</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: radial-gradient(ellipse at center, #0d0d1a 0%, #000000 100%);
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            min-height: 100dvh;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #videoContainer {
            position: fixed;
            bottom: 16px;
            right: 16px;
            z-index: 20;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1);
            background: #000;
        }

        #videoWrapper {
            position: relative;
            width: 200px;
            height: 150px;
        }

        #webcam, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #webcam {
            transform: scaleX(-1);
        }

        #overlayCanvas {
            transform: scaleX(-1);
            pointer-events: none;
        }

        .hidden {
            display: none !important;
        }

        #gesturePanel {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 20;
            background: rgba(12, 12, 24, 0.9);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 16px;
            color: #fff;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        #gesturePanel h2 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            font-weight: 500;
        }

        #currentGesture {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(236, 72, 153, 0.2));
            border-radius: 10px;
            text-align: center;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gesture-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .gesture-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            font-size: 11px;
            transition: background 0.2s;
        }

        .gesture-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .gesture-item.active {
            background: rgba(99, 102, 241, 0.3);
            border: 1px solid rgba(99, 102, 241, 0.5);
        }

        .gesture-icon {
            font-size: 16px;
            width: 24px;
            text-align: center;
            flex-shrink: 0;
        }

        .gesture-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow: hidden;
        }

        .gesture-name {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .gesture-effect {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            left: 16px;
            z-index: 20;
            display: flex;
            gap: 8px;
        }

        .control-btn {
            background: rgba(12, 12, 24, 0.9);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 12px 16px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(30, 30, 50, 0.95);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.4), rgba(139, 92, 246, 0.4));
            border-color: rgba(99, 102, 241, 0.5);
        }

        #pinchIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            background: rgba(12, 12, 24, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 16px 28px;
            border-radius: 50px;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #pinchIndicator.visible {
            opacity: 1;
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0d0d1a 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(99, 102, 241, 0.2);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        #instructions {
            position: fixed;
            bottom: 180px;
            right: 16px;
            z-index: 15;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-align: right;
            max-width: 200px;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            #gesturePanel {
                top: auto;
                bottom: 180px;
                left: 8px;
                right: 8px;
                max-width: none;
                padding: 12px;
            }

            .gesture-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
            }

            .gesture-item {
                padding: 6px;
                flex-direction: column;
                text-align: center;
                gap: 4px;
            }

            .gesture-info {
                align-items: center;
            }

            .gesture-effect {
                display: none;
            }

            #videoWrapper {
                width: 140px;
                height: 105px;
            }

            #videoContainer {
                bottom: 8px;
                right: 8px;
            }

            #controls {
                bottom: 8px;
                left: 8px;
            }

            .control-btn {
                padding: 10px 12px;
                font-size: 12px;
            }

            #instructions {
                display: none;
            }

            #currentGesture {
                font-size: 16px;
                padding: 8px;
                margin-bottom: 10px;
            }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            #gesturePanel {
                max-height: calc(100vh - 32px);
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <p class="loading-text">Initializing Hand Tracking...</p>
    </div>

    <!-- Main Canvas -->
    <canvas id="particleCanvas"></canvas>

    <!-- Pinch Indicator -->
    <div id="pinchIndicator">100%</div>

    <!-- Video Feed with Hand Overlay -->
    <div id="videoContainer">
        <div id="videoWrapper">
            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="overlayCanvas"></canvas>
        </div>
    </div>

    <!-- Gesture Panel -->
    <div id="gesturePanel">
        <h2>Current Gesture</h2>
        <div id="currentGesture">üëã Waiting...</div>
        <h2>Gesture Guide</h2>
        <div class="gesture-grid">
            <div class="gesture-item" data-gesture="open">
                <span class="gesture-icon">üñêÔ∏è</span>
                <div class="gesture-info">
                    <span class="gesture-name">Open</span>
                    <span class="gesture-effect">Release</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="fist">
                <span class="gesture-icon">‚úä</span>
                <div class="gesture-info">
                    <span class="gesture-name">Fist</span>
                    <span class="gesture-effect">Absorb</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="fingerHeart">
                <span class="gesture-icon">ü´∞</span>
                <div class="gesture-info">
                    <span class="gesture-name">Finger Heart</span>
                    <span class="gesture-effect">Heart</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="rock">
                <span class="gesture-icon">ü§ò</span>
                <div class="gesture-info">
                    <span class="gesture-name">Rock</span>
                    <span class="gesture-effect">I LOVE YOU</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="peace">
                <span class="gesture-icon">‚úåÔ∏è</span>
                <div class="gesture-info">
                    <span class="gesture-name">Peace</span>
                    <span class="gesture-effect">Made by Jay</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="middle">
                <span class="gesture-icon">üñï</span>
                <div class="gesture-info">
                    <span class="gesture-name">Middle</span>
                    <span class="gesture-effect">Special</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="pinch">
                <span class="gesture-icon">ü§è</span>
                <div class="gesture-info">
                    <span class="gesture-name">Pinch</span>
                    <span class="gesture-effect">3D Heart</span>
                </div>
            </div>
            <div class="gesture-item" data-gesture="follow">
                <span class="gesture-icon">üëÜ</span>
                <div class="gesture-info">
                    <span class="gesture-name">Move</span>
                    <span class="gesture-effect">Follow</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls">
        <button id="toggleCamera" class="control-btn active">
            <span>üì∑</span>
            <span>Camera</span>
        </button>
        <button id="togglePanel" class="control-btn active">
            <span>üìã</span>
            <span>Panel</span>
        </button>
    </div>

    <!-- Instructions -->
    <div id="instructions">
        Move hand to control particles<br>
        Pinch to create 3D heart
    </div>

    <script>
        /**
         * Gesture Particle Universe
         * Interactive particle system controlled by hand gestures
         * Optimized for performance with WebGL-style rendering
         */

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            particleCount: 600,
            particleSize: 2.5,
            transitionSpeed: 0.08,
            followSpeed: 0.12,
            colors: ['#6366f1', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'],
            heartColors: ['#ff1744', '#ff4569', '#ff6b8a', '#ff8fab', '#ffb3c6'],
            pinchMinDist: 0.03,
            pinchMaxDist: 0.25,
            rotationSensitivity: 2.5
        };

        // ==================== GLOBAL STATE ====================
        let canvas, ctx, overlayCanvas, overlayCtx;
        let particles = [];
        let currentGesture = 'none';
        let prevGesture = 'none';
        let handPosition = { x: 0.5, y: 0.5 };
        let prevHandPosition = { x: 0.5, y: 0.5 };
        let pinchDistance = 0.15;
        let heart3DRotation = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let cameraEnabled = true;
        let panelVisible = true;
        let isAbsorbing = false;
        let absorbProgress = 0;
        let handsDetector = null;
        let camera = null;
        let width, height, centerX, centerY;
        let lastFrameTime = 0;
        let animationId;

        // ==================== PARTICLE CLASS ====================
        class Particle {
            constructor() {
                this.reset();
                this.x = Math.random() * width;
                this.y = Math.random() * height;
            }

            reset() {
                this.x = centerX;
                this.y = centerY;
                this.z = 0;
                this.targetX = Math.random() * width;
                this.targetY = Math.random() * height;
                this.targetZ = 0;
                this.vx = 0;
                this.vy = 0;
                this.size = CONFIG.particleSize * (0.5 + Math.random() * 0.5);
                this.baseSize = this.size;
                this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                this.alpha = 0.7 + Math.random() * 0.3;
                this.life = 1;
            }

            update(gesture, handX, handY, deltaTime) {
                const speed = CONFIG.transitionSpeed * (deltaTime / 16);
                
                // Smooth movement to target
                this.x += (this.targetX - this.x) * speed;
                this.y += (this.targetY - this.y) * speed;
                this.z += (this.targetZ - this.z) * speed;

                // Size based on Z depth for 3D effect
                const depthScale = 1 + this.z * 0.003;
                this.size = this.baseSize * Math.max(0.3, depthScale);

                // Update alpha based on life
                if (gesture === 'fist' && isAbsorbing) {
                    this.alpha = Math.max(0, this.life * 0.8);
                }
            }

            draw() {
                if (this.alpha <= 0) return;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.fill();
            }

            setTarget(x, y, z = 0) {
                this.targetX = x;
                this.targetY = y;
                this.targetZ = z;
            }
        }

        // ==================== SHAPE GENERATORS ====================
        
        /**
         * Generate 2D heart shape points
         */
        function generateHeart2D(scale = 1) {
            const points = [];
            const baseScale = Math.min(width, height) * 0.22 * scale;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const t = (i / CONFIG.particleCount) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                const scatter = Math.random() * 0.4;
                points.push({
                    x: centerX + (x * baseScale / 16) * (1 - scatter),
                    y: centerY + (y * baseScale / 16) * (1 - scatter),
                    z: 0
                });
            }
            return points;
        }

        /**
         * Generate 3D heart shape with rotation
         */
        function generate3DHeart(scale, rotX, rotY) {
            const points = [];
            const baseScale = Math.min(width, height) * 0.18 * scale;
            
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Spherical distribution on heart surface
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = Math.random() * 0.3 + 0.7;

                // Heart parametric equations
                const t = u;
                let hx = 16 * Math.pow(Math.sin(t), 3) * r;
                let hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                let hz = Math.sin(v) * 8 * r * Math.sin(t);

                // Apply rotations
                let y1 = hy * cosX - hz * sinX;
                let z1 = hy * sinX + hz * cosX;
                let x2 = hx * cosY + z1 * sinY;
                let z2 = -hx * sinY + z1 * cosY;

                points.push({
                    x: centerX + x2 * baseScale / 16,
                    y: centerY + y1 * baseScale / 16,
                    z: z2 * 3
                });
            }
            return points;
        }

        /**
         * Generate text shape from string
         */
        function generateText(text, offsetY = 0) {
            const points = [];
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            const fontSize = Math.min(width / (text.length * 0.6), height * 0.15);
            tempCtx.font = `bold ${fontSize}px Arial, sans-serif`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'white';
            tempCtx.fillText(text, width / 2, height / 2 + offsetY);
            
            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const textPoints = [];
            const step = Math.max(3, Math.floor(Math.min(width, height) / 200));
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > 100) {
                        textPoints.push({ x, y, z: 0 });
                    }
                }
            }
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (textPoints.length > 0) {
                    const pt = textPoints[Math.floor(Math.random() * textPoints.length)];
                    points.push({
                        x: pt.x + (Math.random() - 0.5) * 3,
                        y: pt.y + (Math.random() - 0.5) * 3,
                        z: 0
                    });
                } else {
                    points.push({ x: centerX, y: centerY, z: 0 });
                }
            }
            
            return points;
        }

        /**
         * Generate middle finger shape
         */
        function generateMiddleFinger() {
            const points = [];
            const fingerWidth = Math.min(width, height) * 0.06;
            const fingerHeight = Math.min(width, height) * 0.25;
            const baseWidth = Math.min(width, height) * 0.15;
            const baseHeight = Math.min(width, height) * 0.12;
            const startY = centerY + height * 0.15;
            
            for (let i = 0; i < Math.floor(CONFIG.particleCount * 0.4); i++) {
                // Finger
                const fx = centerX + (Math.random() - 0.5) * fingerWidth;
                const fy = startY - Math.random() * fingerHeight;
                points.push({ x: fx, y: fy, z: 0 });
            }
            
            for (let i = 0; i < Math.floor(CONFIG.particleCount * 0.3); i++) {
                // Palm base
                const bx = centerX + (Math.random() - 0.5) * baseWidth;
                const by = startY + Math.random() * baseHeight;
                points.push({ x: bx, y: by, z: 0 });
            }
            
            // Fill remaining with random spread
            while (points.length < CONFIG.particleCount) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 30;
                points.push({
                    x: centerX + Math.cos(angle) * dist,
                    y: startY + Math.sin(angle) * dist,
                    z: 0
                });
            }
            
            return points;
        }

        /**
         * Generate explosion pattern from center
         */
        function generateExplosion() {
            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * Math.min(width, height) * 0.45;
                points.push({
                    x: centerX + Math.cos(angle) * dist,
                    y: centerY + Math.sin(angle) * dist,
                    z: 0
                });
            }
            return points;
        }

        /**
         * Generate gather pattern to center
         */
        function generateGather() {
            const points = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40;
                points.push({
                    x: centerX + Math.cos(angle) * dist,
                    y: centerY + Math.sin(angle) * dist,
                    z: 0
                });
            }
            return points;
        }

        /**
         * Generate follow pattern around hand
         */
        function generateFollow(hx, hy) {
            const points = [];
            const screenX = hx * width;
            const screenY = hy * height;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 100 + 20;
                points.push({
                    x: screenX + Math.cos(angle) * dist,
                    y: screenY + Math.sin(angle) * dist,
                    z: 0
                });
            }
            return points;
        }

        // ==================== GESTURE DETECTION ====================
        
        /**
         * Detect gesture from hand landmarks
         */
        function detectGesture(landmarks) {
            if (!landmarks || landmarks.length === 0) return { gesture: 'none', pinchDist: 0 };
            
            const hand = landmarks[0];
            
            // Key landmarks
            const wrist = hand[0];
            const thumbTip = hand[4];
            const thumbIP = hand[3];
            const indexTip = hand[8];
            const indexPIP = hand[6];
            const indexMCP = hand[5];
            const middleTip = hand[12];
            const middlePIP = hand[10];
            const middleMCP = hand[9];
            const ringTip = hand[16];
            const ringPIP = hand[14];
            const ringMCP = hand[13];
            const pinkyTip = hand[20];
            const pinkyPIP = hand[18];
            const pinkyMCP = hand[17];

            // Calculate palm center for hand position
            const palmCenter = {
                x: (wrist.x + indexMCP.x + pinkyMCP.x) / 3,
                y: (wrist.y + indexMCP.y + pinkyMCP.y) / 3
            };
            
            handPosition.x = palmCenter.x;
            handPosition.y = palmCenter.y;

            // Finger extension checks (tip below PIP = extended)
            const indexExtended = indexTip.y < indexPIP.y - 0.03;
            const middleExtended = middleTip.y < middlePIP.y - 0.03;
            const ringExtended = ringTip.y < ringPIP.y - 0.03;
            const pinkyExtended = pinkyTip.y < pinkyPIP.y - 0.03;
            
            // Thumb extension (distance from wrist)
            const thumbExtended = Math.abs(thumbTip.x - wrist.x) > 0.08;

            // Pinch detection (thumb-index distance)
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const isPinching = pinchDist < 0.07;

            // Count extended fingers
            const extendedCount = [indexExtended, middleExtended, ringExtended, pinkyExtended].filter(Boolean).length;

            // Gesture recognition priority

            // 1. Pinch gesture (thumb and index close)
            if (isPinching && !ringExtended && !pinkyExtended) {
                return { gesture: 'pinch', pinchDist };
            }

            // 2. Middle finger (only middle extended)
            if (middleExtended && !indexExtended && !ringExtended && !pinkyExtended) {
                return { gesture: 'middle', pinchDist: 0 };
            }

            // 3. Peace sign (index and middle extended)
            if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                return { gesture: 'peace', pinchDist: 0 };
            }

            // 4. Rock sign (index and pinky extended, middle and ring down)
            if (indexExtended && pinkyExtended && !middleExtended && !ringExtended) {
                return { gesture: 'rock', pinchDist: 0 };
            }

            // 5. Finger heart (thumb and index tips close, forming heart with fingers curved)
            const thumbIndexClose = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y) < 0.06;
            if (thumbIndexClose && !middleExtended && !ringExtended && !pinkyExtended) {
                // Check if forming the characteristic finger heart shape
                const thumbCurved = thumbTip.y < thumbIP.y;
                if (thumbCurved) {
                    return { gesture: 'fingerHeart', pinchDist: 0 };
                }
            }

            // 6. Open hand (all fingers extended)
            if (extendedCount >= 4) {
                return { gesture: 'open', pinchDist: 0 };
            }

            // 7. Fist (no fingers extended)
            if (extendedCount === 0 && !thumbExtended) {
                return { gesture: 'fist', pinchDist: 0 };
            }

            // 8. Pointing/following (just index extended)
            if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                return { gesture: 'follow', pinchDist: 0 };
            }

            return { gesture: 'none', pinchDist: 0 };
        }

        /**
         * Process detected gesture and update particles
         */
        function processGesture(gesture, pinchDist) {
            // Update gesture display
            updateGestureDisplay(gesture);

            // Handle pinch zoom
            if (gesture === 'pinch') {
                const normalizedDist = Math.max(0, Math.min(1, 
                    (pinchDist - CONFIG.pinchMinDist) / (CONFIG.pinchMaxDist - CONFIG.pinchMinDist)
                ));
                pinchDistance = 0.3 + normalizedDist * 1.4;
                
                // Show pinch indicator
                const indicator = document.getElementById('pinchIndicator');
                indicator.textContent = `${Math.round(normalizedDist * 100)}%`;
                indicator.classList.add('visible');

                // Calculate rotation from hand movement
                const dx = handPosition.x - prevHandPosition.x;
                const dy = handPosition.y - prevHandPosition.y;
                targetRotation.y += dx * CONFIG.rotationSensitivity;
                targetRotation.x += dy * CONFIG.rotationSensitivity;

                // Smooth rotation
                heart3DRotation.x += (targetRotation.x - heart3DRotation.x) * 0.1;
                heart3DRotation.y += (targetRotation.y - heart3DRotation.y) * 0.1;

                // Generate 3D heart
                const points = generate3DHeart(pinchDistance, heart3DRotation.x, heart3DRotation.y);
                particles.forEach((p, i) => {
                    if (points[i]) {
                        p.setTarget(points[i].x, points[i].y, points[i].z);
                        p.color = CONFIG.heartColors[Math.floor(Math.random() * CONFIG.heartColors.length)];
                        p.life = 1;
                        p.alpha = 0.8;
                    }
                });
            } else {
                document.getElementById('pinchIndicator').classList.remove('visible');
                
                // Reset rotation when not pinching
                if (prevGesture === 'pinch') {
                    targetRotation = { x: 0, y: 0 };
                }
            }

            // Handle gesture changes
            if (gesture !== prevGesture) {
                let points;
                
                switch (gesture) {
                    case 'open':
                        isAbsorbing = false;
                        points = generateExplosion();
                        particles.forEach((p, i) => {
                            p.life = 1;
                            p.alpha = 0.8;
                            p.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                            if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                        });
                        break;

                    case 'fist':
                        isAbsorbing = true;
                        absorbProgress = 0;
                        points = generateGather();
                        particles.forEach((p, i) => {
                            if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                        });
                        break;

                    case 'fingerHeart':
                        isAbsorbing = false;
                        points = generateHeart2D();
                        particles.forEach((p, i) => {
                            p.life = 1;
                            p.alpha = 0.85;
                            p.color = CONFIG.heartColors[Math.floor(Math.random() * CONFIG.heartColors.length)];
                            if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                        });
                        break;

                    case 'rock':
                        isAbsorbing = false;
                        points = generateText('I LOVE YOU');
                        particles.forEach((p, i) => {
                            p.life = 1;
                            p.alpha = 0.8;
                            p.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                            if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                        });
                        break;

                    case 'peace':
                        isAbsorbing = false;
                        points = generateText('Made by Jay');
                        particles.forEach((p, i) => {
                            p.life = 1;
                            p.alpha = 0.8;
                            p.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                            if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                        });
                        break;

                    case 'middle':
                        isAbsorbing = false;
                        // Split particles between text and finger
                        const textPoints = generateText('PAKYU KARIN BOI', -height * 0.12);
                        const fingerPoints = generateMiddleFinger();
                        const splitIndex = Math.floor(CONFIG.particleCount * 0.6);
                        
                        particles.forEach((p, i) => {
                            p.life = 1;
                            p.alpha = 0.85;
                            p.color = i < splitIndex ? '#f43f5e' : '#ef4444';
                            if (i < splitIndex && textPoints[i]) {
                                p.setTarget(textPoints[i].x, textPoints[i].y, 0);
                            } else if (fingerPoints[i - splitIndex]) {
                                p.setTarget(fingerPoints[i - splitIndex].x, fingerPoints[i - splitIndex].y, 0);
                            }
                        });
                        break;

                    case 'follow':
                        isAbsorbing = false;
                        particles.forEach(p => {
                            p.life = 1;
                            p.alpha = 0.75;
                        });
                        break;

                    default:
                        isAbsorbing = false;
                }

                prevGesture = gesture;
            }

            // Continuous updates for follow gesture
            if (gesture === 'follow') {
                const points = generateFollow(handPosition.x, handPosition.y);
                particles.forEach((p, i) => {
                    if (points[i]) p.setTarget(points[i].x, points[i].y, 0);
                });
            }

            // Continuous updates for fist (absorb)
            if (gesture === 'fist' && isAbsorbing) {
                absorbProgress += 0.015;
                particles.forEach(p => {
                    p.life = Math.max(0, 1 - absorbProgress);
                });
            }

            prevHandPosition.x = handPosition.x;
            prevHandPosition.y = handPosition.y;
            currentGesture = gesture;
        }

        /**
         * Update gesture display UI
         */
        function updateGestureDisplay(gesture) {
            const displayEl = document.getElementById('currentGesture');
            const items = document.querySelectorAll('.gesture-item');
            
            const gestureNames = {
                'none': 'üëã Waiting...',
                'open': 'üñêÔ∏è Open Palm',
                'fist': '‚úä Fist',
                'fingerHeart': 'ü´∞ Finger Heart',
                'rock': 'ü§ò Rock Sign',
                'peace': '‚úåÔ∏è Peace Sign',
                'middle': 'üñï Middle Finger',
                'pinch': 'ü§è Pinch',
                'follow': 'üëÜ Following'
            };
            
            displayEl.textContent = gestureNames[gesture] || 'üëã Waiting...';
            
            items.forEach(item => {
                item.classList.toggle('active', item.dataset.gesture === gesture);
            });
        }

        // ==================== HAND TRACKING SETUP ====================
        
        /**
         * Handle hand detection results
         */
        function onHandResults(results) {
            // Draw hand skeleton on overlay
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    // Draw connections
                    drawConnectors(overlayCtx, landmarks, HAND_CONNECTIONS, {
                        color: 'rgba(99, 102, 241, 0.6)',
                        lineWidth: 2
                    });
                    // Draw landmarks
                    drawLandmarks(overlayCtx, landmarks, {
                        color: 'rgba(236, 72, 153, 0.8)',
                        lineWidth: 1,
                        radius: 3
                    });
                }
                
                const { gesture, pinchDist } = detectGesture(results.multiHandLandmarks);
                processGesture(gesture, pinchDist);
            } else {
                processGesture('none', 0);
            }
        }

        /**
         * Initialize MediaPipe Hands
         */
        async function initHandTracking() {
            try {
                handsDetector = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                handsDetector.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                handsDetector.onResults(onHandResults);

                const videoElement = document.getElementById('webcam');
                
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (cameraEnabled && handsDetector) {
                            await handsDetector.send({ image: videoElement });
                        }
                    },
                    width: 640,
                    height: 480
                });

                await camera.start();
                document.getElementById('loadingScreen').classList.add('hidden');
                
            } catch (error) {
                console.error('Hand tracking initialization failed:', error);
                document.querySelector('.loading-text').textContent = 
                    'Camera access required. Please enable and refresh.';
            }
        }

        // ==================== CANVAS SETUP ====================
        
        function initCanvas() {
            canvas = document.getElementById('particleCanvas');
            ctx = canvas.getContext('2d');
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            
            resizeCanvas();
            
            // Initialize particles
            particles = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            
            canvas.width = width;
            canvas.height = height;
            
            const videoWrapper = document.getElementById('videoWrapper');
            overlayCanvas.width = videoWrapper.offsetWidth;
            overlayCanvas.height = videoWrapper.offsetHeight;
        }

        // ==================== ANIMATION LOOP ====================
        
        function animate(timestamp) {
            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            // Clear with fade for trails
            ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
            ctx.fillRect(0, 0, width, height);

            // Update and draw particles
            for (const particle of particles) {
                particle.update(currentGesture, handPosition.x, handPosition.y, deltaTime);
                particle.draw();
            }

            // Draw subtle connections
            ctx.globalAlpha = 0.15;
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i < particles.length; i += 8) {
                for (let j = i + 1; j < particles.length; j += 8) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = dx * dx + dy * dy;
                    
                    if (dist < 3000) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1;

            animationId = requestAnimationFrame(animate);
        }

        // ==================== EVENT HANDLERS ====================
        
        function setupEventListeners() {
            window.addEventListener('resize', () => {
                resizeCanvas();
                // Regenerate current shape on resize
                if (currentGesture !== 'none') {
                    prevGesture = 'none';
                    processGesture(currentGesture, pinchDistance);
                }
            });

            document.getElementById('toggleCamera').addEventListener('click', () => {
                cameraEnabled = !cameraEnabled;
                const btn = document.getElementById('toggleCamera');
                const container = document.getElementById('videoContainer');
                
                btn.classList.toggle('active', cameraEnabled);
                container.classList.toggle('hidden', !cameraEnabled);
                
                if (!cameraEnabled) {
                    processGesture('none', 0);
                }
            });

            document.getElementById('togglePanel').addEventListener('click', () => {
                panelVisible = !panelVisible;
                const btn = document.getElementById('togglePanel');
                const panel = document.getElementById('gesturePanel');
                
                btn.classList.toggle('active', panelVisible);
                panel.classList.toggle('hidden', !panelVisible);
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'c' || e.key === 'C') {
                    document.getElementById('toggleCamera').click();
                }
                if (e.key === 'p' || e.key === 'P') {
                    document.getElementById('togglePanel').click();
                }
            });
        }

        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            setupEventListeners();
            animate(0);
            initHandTracking();
        });
    </script>
</body>
</html>